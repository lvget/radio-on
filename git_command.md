# Перейти в ветку main (если не в ней)
git checkout main

# Скачать все изменения
git fetch --all

# Жёсткий сброс к origin/main
git reset --hard origin/main

# Удалить мусор (если нужно)
git clean -fd

Чтобы затянуть изменения из удалённого репозитория Git и **полностью перезаписать локальные изменения** (игнорируя свои правки), выполните следующие команды:

### 1. **Загрузите изменения из удалённого репозитория:**
```bash
git fetch --all
```
Эта команда получает все изменения из удалённого репозитория, но не применяет их.

### 2. **Сбросьте текущую ветку к состоянию удалённой ветки:**
```bash
git reset --hard origin/<ваша-ветка>
```
Замените `<ваша-ветка>` на имя вашей ветки (например, `main`, `master` или `develop`).  
**Что это делает:**
- Жёсткий сброс (`--hard`) удаляет все ваши **незакоммиченные изменения** в отслеживаемых файлах.
- Приводит локальную ветку в точное соответствие с `origin/<ваша-ветка>`.

---

### Если нужно удалить **неотслеживаемые файлы/папки** (опционально):
```bash
git clean -fd
```
- `-f` (force) — удаляет неотслеживаемые файлы.
- `-d` — удаляет неотслеживаемые папки.

---

### Как упростить?
Если текущая ветка отслеживает удалённую (`origin/<ветка>`), можно использовать:
```bash
git reset --hard @{u}
```
`@{u}` — псевдоним для upstream-ветки (например, `origin/main`).

---

### Важно!
- **Это безвозвратно удалит:**  
  Все незакоммиченные изменения (как в рабочей директории, так и в индексе).  
  Неотслеживаемые файлы удалятся, если добавили `git clean -fd`.
- **Рекомендация:**  
  Если есть важные правки — создайте ветку или сделайте `git stash` перед сбросом:
  ```bash
  git stash  # временно сохранить изменения
  git reset --hard origin/main
  # После можно восстановить: git stash pop (если нужно)
  ```

---

### Итоговый пример:
```bash
# Перейти в ветку main (если не в ней)
git checkout main

# Скачать все изменения
git fetch --all

# Жёсткий сброс к origin/main
git reset --hard origin/main

# Удалить мусор (если нужно)
git clean -fd
```